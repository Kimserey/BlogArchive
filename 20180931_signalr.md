# SignalR with ASP Net Core

SignalR is a framework from ASP NET Core allowing us to establish a two way communication between client and server. This two way communication allows the client to send messages to the server but more importantly allows the server to push messages to the client. 
SignalR makes use of Websocket when available else it falls back to SSE or pulling. Today we will focus on how to setup SignalR to work with WSS, Websocket secure and how we can authenticate the user requesting to connect to our SignalR hub via Webscoket.

1. Getting stateds with SignalR
2. SSL encryption for Websocket Secure WSS
3. Websocket Authentication with Identity Server 4

## 1. Getting stateds with SignalR

The `Hubs` are the main components of SignalR. It is an abstraction of a two way communication available for both client and server. Public functions from the hub can be called from the server code and can be called from the client. The frontend NPM package `@aspnet/signalr` library makes the public functions available from Javascript for client side coding.

This example contains source code from the [ASP NET Core official documentation](https://docs.microsoft.com/en-us/aspnet/core/signalr/hubs?view=aspnetcore-2.1).

### 1.1 SignalR Hub

Let's start by creating our first hub by creating an empty project.
ASP NET Core 2.1 comes with SignalR built in so we can directly create a hub.

```c#
public class ChatHub : Hub
{
    public override async Task OnConnectedAsync()
    {
        await Groups.AddToGroupAsync(Context.ConnectionId, "SignalR Users");
        await base.OnConnectedAsync();
    }

    public override async Task OnDisconnectedAsync(Exception exception)
    {
        await Groups.RemoveFromGroupAsync(Context.ConnectionId, "SignalR Users");
        await base.OnDisconnectedAsync(exception);
    }

    public async Task SendMessage(string user, string message)
    {
        await Clients.All.SendAsync("ReceiveMessage", user, message);
    }
}
```

This class inherit from `Hub`, the base class provided by SignalR. It provides facilities to send messages to clients and groups and access the context of the request.
In this example, after being connected, the connection is added to a group called `SignalR Users`. This group can be used to send messages using `await Clients.Group("SignalR Users").SendAsync("ReceiveMessage");`. But in this example, we send the message to all users with `Clients.All` when it is received.

Next we need to configure SignalR and add it to the application builder in `Startup.cs`.

```c#
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddSignalR();
        services.AddMvc();
    }

    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        app.UseStaticFiles();

        app.UseSignalR(hubRouteBuilder => {
            hubRouteBuilder.MapHub<ChatHub>("/chathub");
        });

        app.UseMvc();
    }
}
```

We start to add SignalR in the services `.AddSignalR()` and next we register the hub in a path accessible with `.MapHub<ChatHub>("/chathub");`. This will make the communication with the `ChatHub` available onto `localhost:5000/chathub`.

Next we create a simple Razor page under `/Pages/Index.cshtml` together with its `PageModel` under `/Pages/Index.cshtml.cs`.

```html
@page
@model Example.Pages.IndexModel
@{
    Layout = null;
}

<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <title>Index</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.2/css/bootstrap.min.css" integrity="sha384-Smlep5jCw/wG7hdkwQ/Z5nLIefveQRIY9nfy6xoR1uRYBtpZgI6339F5dgvm/e9B" crossorigin="anonymous">
</head>
<body>
    <div class="container">
        <div class="row">
            <div class="col-6">
                <form>
                    <div class="form-group">
                        <label for="userInput">User</label>
                        <input type="text" class="form-control" id="userInput" aria-describedby="userHelp" placeholder="Enter User">
                    </div>
                    <div class="form-group">
                        <label for="messageInput">Message</label>
                        <input type="text" class="form-control" id="messageInput" aria-describedby="messageHelp" placeholder="Enter Message">
                    </div>
                    <button type="button" id="sendButton" class="btn btn-primary">Send Message</button>
                </form>
            </div>
            <div class="col-6">
                <ul id="messagesList"></ul>
            </div>
        </div>
    </div>
</body>
</html>
```

_If you are not familiar with Razor pages, you can refer to my previous blog post on [LibMan with Razor page](https://kimsereyblog.blogspot.com/2018/05/asp-net-core-client-side-libraries.html)._

We created two textboxes, one for the username and the other for the message. What we need to do next is to submit the message to SignalR Hub when the user click on the button. The message will then be dispatched to all clients as coded `Clients.All` in the hub.
We start first by adding SignalR by running `npm install @aspnet/signalr --save`. This downloads the source code under `node_modules`. For the sake of this example, we copy the `signalr` file from `/node_modules/@aspnet/signalr/dist/browser/signalr.js` and paste it under `/wwwroot/libs/signalr.js`.

Next we reference it from the `index.cshtml`:

```
<script src="~/libs/signalr.js"></script>
```

Referencing `signalr.js` provides access to `signalR` which then gives access to the `HubConnectionBuilder`. Using that, we can code the connection and sending/receiving messages from and to the hub:

```js
<script>
    const connection = new signalR.HubConnectionBuilder()
        .withUrl("/chathub")
        .configureLogging(signalR.LogLevel.Trace)
        .build();

    connection.on("ReceiveMessage", (user, message) => {
        const li = document.createElement("li");
        li.textContent = user + " says " + message;
        document.getElementById("messagesList").appendChild(li);
    });

    connection.start().catch(err => console.error(err.toString()));

    document.getElementById("sendButton").addEventListener("click", event => {
        const user = document.getElementById("userInput").value;
        const message = document.getElementById("messageInput").value;
        connection.invoke("SendMessage", user, message).catch(err => console.error(err.toString()));
        event.preventDefault();
    });
</script>
```

We start by building a hub  connection using the `HubConnectionBuilder`. We set the log level to `Trace` to print more logs in Chrome console. Next we register a handler on `ReceiveMessage` which is the function specified in the hub `Clients.All.SendAsync("ReceiveMessage", user, message);`. The arguments correspond to the function on the hub too with `(user, message)`.
Lastly we start the connection, it is recommended to register handlers before starting the connection to avoid losing messages.

And that's all we need, once we run, we should now be able to have a Websocket communication and send message to the hub and receive message from the hub. Here is the full code of the `index.cshtml`.

```html
@page
@model Example.Pages.IndexModel
@{
    Layout = null;
}

<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <title>Index</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.2/css/bootstrap.min.css" integrity="sha384-Smlep5jCw/wG7hdkwQ/Z5nLIefveQRIY9nfy6xoR1uRYBtpZgI6339F5dgvm/e9B" crossorigin="anonymous">
</head>
<body>
    <div class="container">
        <div class="row">
            <div class="col-6">
                <form>
                    <div class="form-group">
                        <label for="userInput">User</label>
                        <input type="text" class="form-control" id="userInput" aria-describedby="userHelp" placeholder="Enter User">
                    </div>
                    <div class="form-group">
                        <label for="messageInput">Message</label>
                        <input type="text" class="form-control" id="messageInput" aria-describedby="messageHelp" placeholder="Enter Message">
                    </div>
                    <button type="button" id="sendButton" class="btn btn-primary">Send Message</button>
                </form>
            </div>
            <div class="col-6">
                <ul id="messagesList"></ul>
            </div>
        </div>
    </div>

    <script src="~/libs/signalr.js"></script>
    <script>
        const connection = new signalR.HubConnectionBuilder()
            .withUrl("/chathub")
            .configureLogging(signalR.LogLevel.Trace)
            .build();

        connection.on("ReceiveMessage", (user, message) => {
            const li = document.createElement("li");
            li.textContent = user + " says " + message;
            document.getElementById("messagesList").appendChild(li);
        });

        connection.start().catch(err => console.error(err.toString()));

        document.getElementById("sendButton").addEventListener("click", event => {
            const user = document.getElementById("userInput").value;
            const message = document.getElementById("messageInput").value;
            connection.invoke("SendMessage", user, message).catch(err => console.error(err.toString()));
            event.preventDefault();
        });
    </script>
</body>
</html>
```

## 2. SSL encryption for Websocket Secure WSS

Just like HTTPS for HTTP, Websocket can be secured via SSL (WSS). When we run under `http://localhost:5000` and open the chrome debugging console, we can see the information message telling that we have established connection with `ws://localhost:5000/chathub`. `ws` being the none secure websocket connection. When we switch to `https://localhost:5001`, we see that the connection establish is on `wss://localhost:5001/chathub`. `wss` being the secure websocket connection.

SingalR detects the scheme used and establish the proper websocket connection. If none secure, it will use `ws` and if secured, it will use `wss`.

Now that we know how SignalR works and how to have the connection encrypted, let's see how we can have the communication protected by and authentication mechanism.

## 3. Websocket Authentication with Identity Server 4

