# Logging in ASP NET Core with Serilog

At each stages of the development cycle, good logs are necessary to debug and fix bugs efficiently.
Serilog is a logging framework which allows to log structured logs into different platforms called sinks.
Today we will see how we can set it up in three parts

```
1. Serilog for ASP.NET Core
2. Console sink
3. Rolling File sink
4. Environment enricher
```

## 1. Serilog for ASP.NET Core

Serilog is a logging framework providing facilities to write structured logs into different platforms called sinks.

### 1.1 Structured logs

Logs are string messages describing an event in the system. To build log messages, we assemble pieces of information like elapsed time or process name and arrange it into a string which we then write to an ouput stream, console or file for example.
The end data available is the timestamp of the log and the log message. Using this log message, all we can do to query is a full text search query.
If our log contained an elasped time counter, it would not be easy to run a query against it.

_Structure logs cater for that by saving the logs as a structured json object where all pieces are kept_. The advantage is that it provides full flexibility by allowing to query on the properties where items are typed. The other advantage is that it provides a unified way to allow multiple platform to write to their own output the logs in their own way since they get all raw propeties.

This is an example of structured logs:

```
{
  "Timestamp": "2018-02-21T09:06:26.8380962+08:00",
  "Level": "Information",
  "MessageTemplate": "Executed action {ActionName} in {ElapsedMilliseconds}ms",
  "RenderedMessage": "Executed action \"WebApplication.Controllers.ValuesController.Errors (WebApplication)\" in 1.6461ms",
  "Properties": {
    "ActionName": "WebApplication.Controllers.ValuesController.Errors (WebApplication)",
    "ElapsedMilliseconds": 1.6461000000000001,
    "EventId": {
      "Id": 2
    },
    "SourceContext": "Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker",
    "ActionId": "1f889c5e-c631-464b-992c-640202498b30",
    "RequestId": "0HLBOOSMLU5EE:00000003",
    "RequestPath": "/api/values/errors",
    "MachineName": "DESKTOP-I8R7QHH",
    "Application": "Web"
  }
}
```

### 1.2 ASP.NET Core

To start using Serilog on ASP.NET Core, we can start by downloading [`Serilog.AspNetCore`](https://www.nuget.org/packages/Serilog.AspNetCore) and register Serilog on the WebHostBuilder in `program.cs`.

```
WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .UseSerilog()
    .Build();
```

We can already configure directly the logger from the code.

```
 WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .UseSerilog((ctx, cfg) =>
    {
        cfg.ReadFrom.Configuration(ctx.Configuration)
            .MinimumLevel.Debug()
            .MinimumLevel.Override("Microsoft", LogEventLevel.Information);
    })
    .Build();
```

But if we want to use the Configuration framework to configure Serilog, we can download [`Serilog.Settings.Configuration`](https://www.nuget.org/packages/Serilog.Settings.Configuration) and configure Serilog to read from configuration.
One of the advantage of using the Configuration framework is the ability to configure the logger from `appsettings.json` and leverage the multi environment support from `appsettings.json` with `appsettings.Development.json` or `appsettings.Production.json`. After installing `Serilog.Settings.Configuration`, we can use it with `.ReadFrom()`.

```
WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .UseSerilog((ctx, cfg) => cfg.ReadFrom.Configuration(ctx.Configuration))
    .Build();
```

In case of errors within Serilog, it is possible to debug logs from Serilog using `SelfLog`.

```
Serilog.Debugging.SelfLog.Enable(msg => Debug.WriteLine(msg));
```

From the example we saw that we can configure a default minimum level of logging `.MinimumLevel.Debug()`. We can also override that default for certain namespaces, for example here we set the minimum level of logging for `Microsoft` namespace to `Information`. This will prevent ASP.NET Core to log all debug logs while keeping our own debug logs.

## 2 Console sink

Serilog alone does not write logs anywhere. It only construct the structured logs. To write to an ouput, we need to configure a __sink__. The most common one is [`Serilog.Sinks.Console`](https://www.nuget.org/packages/Serilog.Sinks.Console). Once we installed it, we can write to console by simply adding `WriteTo.Console()`.

```
 WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .UseSerilog((ctx, cfg) =>
    {
        cfg.ReadFrom.Configuration(ctx.Configuration)
            .MinimumLevel.Debug()
            .MinimumLevel.Override("Microsoft", LogEventLevel.Information)
            .WriteTo.Console();
    })
    .Build();
```

Or configure it from appsettings.

```
{
  "Serilog": {
    "MinimumLevel": {
        "Default": "Debug",
        "Override": {
            "Microsoft": "Warning"
        }
    },
    "WriteTo": [
      { "Name": "Console" }
    ]
  }
}
```

Other properties are available on each logs. For example the `SourceContext` is the namespace where the log originated. If we want to display it on each log we only need to change the default template of the Console.

```
cfg.ReadFrom.Configuration(ctx.Configuration)
    .MinimumLevel.Debug()
    .MinimumLevel.Override("Microsoft", LogEventLevel.Information)
    .WriteTo.Console(outputTemplate: "[{Timestamp:HH:mm:ss.fff} {Level:u3}] {SourceContext}: {Message:lj}{NewLine}{Exception}")
```

From then on the logs should contain the source context.

```
[2018-02-21 09:06:26.837 +08:00 Web INF] Microsoft.AspNetCore.Mvc.StatusCodeResult: Executing HttpStatusCodeResult, setting HTTP status code 200
```

## 3. Rolling Files sink

By writing to Console we can see live logs appearing but when we close the application, all the logs are gone as non of them are persisted. This is incredibly useful while developing as most of the time we don't want to know what happened in a past execution.
But in production, it is necessary to persist logs as the application will run without us monitoring it with all our attention.
The simplest way to monitor logs is through files. Saving logs to file allows us to reference back previous executions by looking into the file.

Similarly to Console sink providing writing to console, Rolling Files sink provides a

[complete]

### 1.3 Environment enricher

We configured the Console sink and as we see,  it write messages on the console with predefined data like timestamp, log level of the messages and of course the message content and exception if any.



Enrich will add extra properties to the log in order to provide more information.

Sinks are the pieces in charge of sinking down the log to outputs.

In case of errors within Serilog, it is possible to debug logs from Serilog from ....


[complete]