# Logging in ASP NET Core with Serilog

At each stages of the development cycle, good logs are necessary to debug and fix bugs efficiently.
Serilog is a logging framework which allows to log structured logs into different platforms called sinks.
Today we will see how we can set it up in three parts

1. Serilog for ASP.NET Core
2. Console sink
3. Rolling File sink
4. Environment enricher

All the code discussed here can be found on my GitHub [https://github.com/Kimserey/SerilogTest](https://github.com/Kimserey/SerilogTest).

## 1. Serilog for ASP.NET Core

Serilog is a logging framework providing facilities to write structured logs into different platforms called sinks.

### 1.1 Structured logs

Logs are string messages describing an event in the system. To build log messages, we assemble pieces of information like elapsed time or process name and arrange it into a string which we then write to an ouput stream, console or file for example.
The end data available is the timestamp of the log and the log message. Using this log message, all we can do to query is a full text search query.
If our log contained an elasped time counter, it would not be easy to run a query against it.

_Structure logs cater for that by saving the logs as a structured json object where all pieces are kept_. The advantage is that it provides full flexibility by allowing to query on the properties where items are typed. The other advantage is that it provides a unified way to allow multiple platform to write to their own output the logs in their own way since they get all raw propeties.

This is an example of structured logs:

```JSON
{
  "Timestamp": "2018-02-21T09:06:26.8380962+08:00",
  "Level": "Information",
  "MessageTemplate": "Executed action {ActionName} in {ElapsedMilliseconds}ms",
  "RenderedMessage": "Executed action \"WebApplication.Controllers.ValuesController.Errors (WebApplication)\" in 1.6461ms",
  "Properties": {
    "ActionName": "WebApplication.Controllers.ValuesController.Errors (WebApplication)",
    "ElapsedMilliseconds": 1.6461000000000001,
    "EventId": {
      "Id": 2
    },
    "SourceContext": "Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker",
    "ActionId": "1f889c5e-c631-464b-992c-640202498b30",
    "RequestId": "0HLBOOSMLU5EE:00000003",
    "RequestPath": "/api/values/errors",
    "MachineName": "DESKTOP-I8R7QHH",
    "Application": "Web"
  }
}
```

### 1.2 ASP.NET Core

To start using Serilog on ASP.NET Core, we can start by downloading [`Serilog.AspNetCore`](https://www.nuget.org/packages/Serilog.AspNetCore) and register Serilog on the WebHostBuilder in `program.cs`.

```C#
WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .UseSerilog()
    .Build();
```

We can already configure directly the logger from the code.

```C#
 WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .UseSerilog((ctx, cfg) =>
    {
        cfg.ReadFrom.Configuration(ctx.Configuration)
            .MinimumLevel.Debug()
            .MinimumLevel.Override("Microsoft", LogEventLevel.Information);
    })
    .Build();
```

But if we want to use the Configuration framework to configure Serilog, we can download [`Serilog.Settings.Configuration`](https://www.nuget.org/packages/Serilog.Settings.Configuration) and configure Serilog to read from configuration.
One of the advantage of using the Configuration framework is the ability to configure the logger from `appsettings.json` and leverage the multi environment support from `appsettings.json` with `appsettings.Development.json` or `appsettings.Production.json`. After installing `Serilog.Settings.Configuration`, we can use it with `.ReadFrom()`.

```C#
WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .UseSerilog((ctx, cfg) => cfg.ReadFrom.Configuration(ctx.Configuration))
    .Build();
```

In case of errors within Serilog, it is possible to debug logs from Serilog using `SelfLog`.

```C#
Serilog.Debugging.SelfLog.Enable(msg => Debug.WriteLine(msg));
```

From the example we saw that we can configure a default minimum level of logging `.MinimumLevel.Debug()`. We can also override that default for certain namespaces, for example here we set the minimum level of logging for `Microsoft` namespace to `Information`. This will prevent ASP.NET Core to log all debug logs while keeping our own debug logs.

## 2 Console sink

Serilog alone does not write logs anywhere. It only construct the structured logs. To write to an ouput, we need to configure a __sink__. The most common one is [`Serilog.Sinks.Console`](https://www.nuget.org/packages/Serilog.Sinks.Console). Once we installed it, we can write to console by simply adding `WriteTo.Console()`.

```C#
 WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .UseSerilog((ctx, cfg) =>
    {
        cfg.ReadFrom.Configuration(ctx.Configuration)
            .MinimumLevel.Debug()
            .MinimumLevel.Override("Microsoft", LogEventLevel.Information)
            .WriteTo.Console();
    })
    .Build();
```

Or configure it from appsettings.

```JSON
{
  "Serilog": {
    "MinimumLevel": {
        "Default": "Debug",
        "Override": {
            "Microsoft": "Warning"
        }
    },
    "WriteTo": [
      { "Name": "Console" }
    ]
  }
}
```

Other properties are available on each logs. For example the `SourceContext` is the namespace where the log originated. If we want to display it on each log we only need to change the default template of the Console.

```C#
cfg.ReadFrom.Configuration(ctx.Configuration)
    .MinimumLevel.Debug()
    .MinimumLevel.Override("Microsoft", LogEventLevel.Information)
    .WriteTo.Console(outputTemplate: "[{Timestamp:HH:mm:ss.fff} {Level:u3}] {SourceContext}: {Message:lj}{NewLine}{Exception}")
```

From then on the logs should contain the source context.

```TXT
[2018-02-21 09:06:26.837 +08:00 Web INF] Microsoft.AspNetCore.Mvc.StatusCodeResult: Executing HttpStatusCodeResult, setting HTTP status code 200
```

## 3. Rolling Files sink

By writing to Console we can see live logs appearing but when we close the application, all the logs are gone as none of them are persisted. Writing to console is useful while developing as most of the time we only care about what is going on during the execution and we don't care about past executions.
But in production, it is necessary to persist logs as the application will run without us monitoring it with all our attention. On top of that there are time where the application we can't have access to a console output in a remote system.

In those instances, the simplest way to monitor logs is through files. Saving logs to files allows us to reference back previous executions by looking into the file or even to monitor the file remotely.

Similarly to Console sink providing writing to console, Rolling Files sink comes from a package [`Serilog.Sink.RollingFile`](https://www.nuget.org/packages/serilog.sinks.rollingfile/). After installation we can configure in the same way we configured the Console log, except that we will need to provide a file path for the logs to be saved.

```C#
cfg.ReadFrom.Configuration(ctx.Configuration)
    .MinimumLevel.Debug()
    .MinimumLevel.Override("Microsoft", LogEventLevel.Information)
    .WriteTo.RollingFile("Logs\\Web-{Date}.log", outputTemplate: "[{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} {Level:u3}] {SourceContext}: {Message:lj}{NewLine}{Exception}")
```

After we configured the environment we can see the log files appearing under the folder configured.

## 4. Environment enricher

With the sinks configured, we can see the messages outputed with predefined data like timestamp, log level of the messages and of course the message content and exception if any.
Apart from those information, our logs might be holding more data which aren't part of the template therefore not displayed which we have seen how to display by changing the template.

One of the enricher is the environment enricher which provides information about the machine name and the environment user name, the user running the application.

Similarly as the sinks, enricher are added using packages. For the environment enricher, we add the [`Serilog.Enrich.Environment`](https://www.nuget.org/packages/serilog.enrichers.environment/). Once installed, we can then enrich our logs.

```C#
cfg.ReadFrom.Configuration(ctx.Configuration)
    .MinimumLevel.Debug()
    .MinimumLevel.Override("Microsoft", LogEventLevel.Information)
    .Enrich.WithMachineName()
    .Enrich.WithEnvironmentUserName()
    .WriteTo.Console(theme: AnsiConsoleTheme.Code, outputTemplate: "{MachineName} {EnvironmentUserName}: {Message:lj}{NewLine}{Exception}")
```

Now if we look at the log, we should be able to see the new information in the logs.
And that conclude our simple way to write logs to console and persist them in log files using Serilog!

## Conclusion

Logs are the best tools that developers have to write programs. Having a powerful logging system is important but the simplicity of it also need to be taken into consideration. Serilog provides an easy way to configure simple Console and Rolling file logs and at the same time cater for expansion of the code towards more heavy duty tools like the Elastic stack. Hope you liked this post. See you next time!
