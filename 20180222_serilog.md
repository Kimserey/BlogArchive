# Logging in ASP NET Core with Serilog

At each stages of the development cycle, good logs are necessary to debug and fix bugs efficiently.
Serilog is a logging framework which allows to log structured logs into different platforms called sinks.
Today we will see how we can set it up in three parts

```
1. Serilog for ASP.NET Core
2. Rolling Files sinks
```

## 1. Serilog for ASP.NET Core

Serilog is a logging framework providing facilities to write structured logs into different platforms called sinks.

__Structured logs__

Logs are string messages describing an event in the system. To build log messages, we assemble pieces of information like elapsed time or process name and arrange it into a string which we then write to an ouput stream, console or file for example.
The end data available is the timestamp of the log and the log message. Using this log message, all we can do to query is a full text search query.
If our log contained an elasped time counter, it would not be easy to run a query against it.

_Structure logs cater for that by saving the logs as a structured json object where all pieces are kept_. The advantage is that it provides full flexibility by allowing to query on the properties where items are typed. The other advantage is that it provides a unified way to allow multiple platform to write to their own output the logs in their own way since they get all raw propeties.

This is an example of structured logs:

```
{
  "Timestamp": "2018-02-21T09:06:26.8380962+08:00",
  "Level": "Information",
  "MessageTemplate": "Executed action {ActionName} in {ElapsedMilliseconds}ms",
  "RenderedMessage": "Executed action \"WebApplication.Controllers.ValuesController.Errors (WebApplication)\" in 1.6461ms",
  "Properties": {
    "ActionName": "WebApplication.Controllers.ValuesController.Errors (WebApplication)",
    "ElapsedMilliseconds": 1.6461000000000001,
    "EventId": {
      "Id": 2
    },
    "SourceContext": "Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker",
    "ActionId": "1f889c5e-c631-464b-992c-640202498b30",
    "RequestId": "0HLBOOSMLU5EE:00000003",
    "RequestPath": "/api/values/errors",
    "MachineName": "DESKTOP-I8R7QHH",
    "Application": "Web"
  }
}
```

### 1.1 ASP.NET Core

To start using Serilog on ASP.NET Core, we can start by downloading [`Serilog.AspNetCore`](https://www.nuget.org/packages/Serilog.AspNetCore/2.1.1-dev-00022) and register Serilog on the WebHostBuilder in `program.cs`.

```
WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .UseSerilog()
    .Build();
```

We can already configure directly the logger from the code.

```
 WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .UseSerilog((ctx, cfg) =>
    {
        cfg.ReadFrom.Configuration(ctx.Configuration)
            .MinimumLevel.Debug()
            .MinimumLevel.Override("Microsoft", LogEventLevel.Information)
            .Enrich.WithMachineName()
            .WriteTo.Console();
    })
    .Build();
```

But if we want to use the Configuration framework to configure Serilog, we can download `Serilog.Settings.Configuration` and configure Serilog to read from configuration.
One of the advantage of using the Configuration framework is the ability to configure the logger from `appsettings.json` and leverage the multi environment support from `appsettings.json` with `appsettings.Development.json` or `appsettings.Production.json`. After installing `Serilog.Settings.Configuration`, we can use it with `.ReadFrom()`.

```
WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .UseSerilog((ctx, cfg) => cfg.ReadFrom.Configuration(ctx.Configuration))
    .Build();
```

In case of errors within Serilog, it is possible to debug logs from Serilog using `SelfLog`.

```
Serilog.Debugging.SelfLog.Enable(msg => Debug.WriteLine(msg));
```

### 1.2 Console sink

We can then configure it to write to console.

```
WriteTo Console
```

Or configure it from appsettings.

```
{}
```

Configuring from appsettings allows us to leverage the multi environment support of the configuration framework. For example we can use it to set different log level for development, integration, uat or production.

Other properties are available on each logs. For example the SourceContext is the namespace where the log originated. If we want to display it on each log we only need to change the default template of the Console.

```
New template
```

From then on the logs should contain the source context.

```
example
```

### 1.3 Environment enricher

We configured the Console sink and as we see,  it write messages on the console with predefined data like timestamp, log level of the messages and of course the message content and exception if any.



Enrich will add extra properties to the log in order to provide more information.

Sinks are the pieces in charge of sinking down the log to outputs.

In case of errors within Serilog, it is possible to debug logs from Serilog from ....


## 2. Rolling Files sink

By writing to Console we can see live logs appearing but when we close the application, all the logs are gone as non of them are persisted. This is incredibly useful while developing as most of the time we don't want to know what happened in a past execution.
But in production, it is necessary to persist logs as the application will run without us monitoring it with all our attention.
The simplest way to monitor logs is through files. Saving logs to file allows us to reference back previous executions by looking into the file.

Similarly to Console sink providing writing to console, Rolling Files sink provides a