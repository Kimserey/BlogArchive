# Swagger

Building a web API is not an easy task. In order to build one easy to use, we need to consider the routes, the HTTP methods, the return results from the endpoints,  the parameter used for the body of the requests, etc...
Swagger is a tool which compiles all our ApI endpoints into a user friendly UI and allows us to directly test our endpoints from the UI.
Today we will see how we can integrate Swagger in 3 parts:

```
1. Add Swagger to ASP NET Core project
2. Handle authentication
3. Handle endpoints specificities with filters
```

## 1. Add Swagger to ASP NET Core project

We start first by creating an empty ASP NET Core project with the following startup:

```
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
    }

    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
    {
        loggerFactory.AddConsole().AddDebug();

        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseMvcWithDefaultRoute();
    }
}
```

We can then add a controller with few endpoints. For example we can create a `BankAccount` controller with deposit and withdraw functionalities:

```
[Route("BankAccount")]
public class BankAccountController: Controller
{
    [HttpPost("{accountName}/Deposit")]
    public IActionResult Deposit(string accountName, [FromBody]double amount) => Ok();

    [HttpPost("{accountName}/Withdraw")]
    public IActionResult Withdraw(string accountName, [FromBody]double amount) => Ok();

    [HttpGet("{accountName}")]
    [ProducesResponseType(typeof(double), 200)]
    public IActionResult Get(string accountName) => Ok(balance);
}
```

Next in order to add Swagger, we need to add Swashbuckle.AspNetCore.

```
Install-Package Swashbuckle.AspNetCore
```

This will install the necessary libraries to use Swagger.
Then we register it on the services using the extension method `AddSwaggerGen()`:

```    
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddSwaggerGen(c =>
    {
        c.SwaggerDoc("api-v1", new Info { Title = "Example API", Version = "v1" });
    });
}
```

The swagger document registration will autogenerate the swagger.json and make it available at `/swagger/{name}/swagger.json`.
Lastly we register both middlewares, the one creating the swagger.json and the one making the GUI available:

```
app.UseSwagger();
app.UseSwaggerUI(c =>
{
    c.SwaggerEndpoint("/swagger/api-v1/swagger.json", "Example API v1");
});
```

Once our application is started, we will be able access Swagger GUI endpoint `/swagger` and we will see our endpoints listed.

![swagger]()

From there we can easily view all our endpoints and see if changes must be made. We can also directly test from here. Lastly our parameters are  discovered together with their class schema which are displayed as example.
This allows us to quickly iterate over the design of our API but most of the APIs include protected endpoints. We will see next how to handle it.

## 2. Handle authentication

In order to authenticate the calls, we need to be able to add the authentication header to the requests.

This can simply be done by adding the security definition in the Swagger gen service registration:

```
services.AddSwaggerGen(c =>
            {
                c.AddSecurityDefinition("Bearer", new ApiKeyScheme
                {
                    Name = "Authorization",
                    In = "header"
                });

                c.OperationFilter<FileOperation>();
                c.SchemaFilter<PatchSchema>();

                c.SwaggerDoc("expenseking", new Info());
            });
```

After that from the top of the Swagger UI, we will be able to add the bearer token for all endpoints.

## 3. Handle endpoints specificities with filters

Swagger UI is actually built from the swagger.json auto generated. But there are times where it is not possible to auto generate the endpoint. 
For example, the handling of files formdata. If we have an endpoint taking files as input:

```
```

The following representation is generated:

```
```

It is not really useful. What we want is to be able to have a file input to directly upload a file from Swagger UI. In order to do that we will use an __OperationFilter__. An operation filter runs through all operations which we can then filter the one we wish to modify.

```
```

We are filtering using the endpoint name then we set the parameter as formData file.
There are 2 types of parameters, BodyParameter which is a json object and NonBodyParamerer. Here we set the parameter type as file in formData. We should now see the filr input.

Image

Another example would be if we have a string value which can be a particular set of data:

[{
Property: name
Value: kim
},
{
Property: age
Value: 30
}]

Property can either be name or age. If we only have the array of properties as parameter, we would have the following example value generated by Swagger:

```
String example
```

From there it is hard to see that property can only be name or age. In order to display a better example, we can overwrite the auto generated oj using a __SchemaFitler__.

```
```

Now our sample on Swagger UI will be as followed:

```
```

# Conclusion

Today we saw how we could integrate swagger to our ASP NET Core project where it can be used to analyze the coherence of our Api and also easily test it through the intuitive Swagger UI. We also saw how we could configure it to support authentication and customise the swagger.json generation using Operation filters to apply modification on the endpoint itself like parameters and using Schema filters to apply modification on the example schema generared. If you have any question leave it below! See you next time!