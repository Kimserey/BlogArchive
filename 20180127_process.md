# Run batch files from C# in DotNet Core

Being able to run batch during the lifecycle of an application is always useful. It gives a way to programmatically interact with any programs which implements a CLI. Today we will see how we can start processes from C# on .NET Core applications and how it can be useful in a real scenario

```
1. Unzip from CLI
2. Use CLI from C#
```

## 1. Unzip from CLI

In this tutorial we will use a process to execute a 7zip command to extract files into a particular input.

If we have 7zip installed and added to PATH, using a terminal, we should able to execute the following from the folder containing the archive:

```
7z x .\\archive.zip -o.\\archive
```

`x` stands for extract and `-o` stands for output directory. The result of this command should be the list of files in extract unzipped into the archive folder.

There are times where it comes handy to zip and unzip as part of an application lifecycle, for example to allow a user to download multiple files from our server, we could zip them and push the zip through HTTP response. But to do that we need to run the command from C#.

## 2. Use CLI from C#

DotNet Core comes with a Process API which can be used to create and execute processes.

We start first by creating a process:

Then we set the start parameters like the file name, the string arguments:

We also set it as such as the process does not create any window and we set it to no use `ShellExecute`:

Setting `UseShellExecute` to false allows to redirect standard output and error. Setting it to true would be used to open files like .html files with default browser or .txt with notepad. In our case we just want to execute a command in the background and redirect the output so we set it to false.

redirect output

UseShellExecute false
CreateNoWindow true
```
var process = new Process();
process.StartInfo.FileName = $"Scripts/deploy.{artifactName}.cmd";
process.StartInfo.RedirectStandardOutput = true;
process.StartInfo.RedirectStandardError = true;
process.StartInfo.CreateNoWindow = true;
process.StartInfo.UseShellExecute = false;
process.Start();
Console.Write(process.StandardOutput.ReadToEnd());
Console.Write(process.StandardError.ReadToEnd());
return Ok();
```